性能调整
===
* knowledgeid: -LdLtaiBADqiIat-6k_c
* author: tei952
* authorid: iHmcxnnRDWPOJAE38On1nCdq0ir2

## 1.0 DNS 预解析
```

DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p>
<p>html</p>
<p><link rel="dns-prefetch" href="//yuchengkai.cn">

```
## 2.0 缓存
```

缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复
加载提高网页的整体加载速度。</p>
<p>通常浏览器缓存策略分为两种：强缓存和协商缓存。</p>
<p>强缓存</p>
<p>实现强缓存可以通过两种响应头实现：&#39;Expires&#39; 和 &#39;Cache-Control&#39; 。强缓
存表示在缓存期间不需要请求，&#39;state code&#39; 为 200</p>
<p>js
Expires: Wed, 22 Oct 2018 08:41:00 GMT</p>
<p>&#39;Expires&#39; 是 HTTP / 1.0 的产物，表示资源会在 &#39;Wed, 22 Oct 2018 08:41:00
 GMT&#39; 后过期，需要再次请求。并且 &#39;Expires&#39; 受限于本地时间，如果
修改了本地时间，可能会造成缓存失效。</p>
<p>js
Cache-control: max-age=30</p>
<p>&#39;Cache-Control&#39; 出现于 HTTP / 1.1，优先级高于 &#39;Expires&#39; 。该属性表示
资源会在 30 秒后过期，需要再次请求。</p>
<p>协商缓存</p>
<p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果
缓存有效会返回 304。</p>
<p>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p>
<p>Last-Modified 和 If-Modified-Since</p>
<p>&#39;Last-Modified&#39; 表示本地文件最后修改日期，&#39;If-Modified-Since&#39; 会将 
&#39;Last-Modified&#39; 的值发送给服务器，询问服务器在该日期后资源是否有更新，
有更新的话就会将新的资源发送回来。</p>
<p>但是如果在本地打开缓存文件，就会造成 &#39;Last-Modified&#39; 被修改，所以在 
HTTP / 1.1 出现了 &#39;ETag&#39; 。</p>
<p>ETag 和 If-None-Match</p>
<p>&#39;ETag&#39; 类似于文件指纹，&#39;If-None-Match&#39; 会将当前 &#39;ETag&#39; 发送给服务器，
询问该资源 &#39;ETag&#39; 是否变动，有变动的话就将新的资源发送回来。并且 &#39;ETag&#39; 
优先级比 &#39;Last-Modified&#39; 高。</p>
<p>选择合适的缓存策略</p>
<p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方
可能需要选择特殊的缓存策略</p>
<p>对于某些不需要缓存的资源，可以使用 &#39;Cache-control: no-store&#39; ，表
示该资源不需要缓存
对于频繁变动的资源，可以使用 &#39;Cache-Control: no-cache&#39; 并配合 &#39;ETag&#39;
 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
对于代码文件来说，通常使用 &#39;Cache-Control: max-age=31536000&#39; 并配
合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的
文件。

```
## 3.0 使用 HTTP / 2.0
```

因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和
断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的
文件会需要更多的时间。</p>
<p>在  HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，
极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请
求的数据大小。</p>
<p>更详细的内容你可以查看 <a href="../Network/Network-zh.md##http-20">该小节</a>

```
## 4.0 预加载
```

在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早
获取，这时候就可以使用预加载。</p>
<p>预加载其实是声明式的 &#39;fetch&#39; ，强制浏览器请求资源，并且不会阻塞 
&#39;onload&#39; 事件，可以使用以下代码开启预加载</p>
<p>html</p>
<link rel="preload" href="http://example.com">

<p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要
的文件延后加载，唯一缺点就是兼容性不好。

```
## 5.0 预渲染
```

可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p>
<p>html</p>
<link rel="prerender" href="http://example.com"> 

<p>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之
后打开，否则就白白浪费资源去渲染

```
## 6.0 优化渲染过程
```
对于代码层面的优化，你可以查阅浏览器系列中的 [相关内容]
(../Browser/4browser-ch.md#渲染机制)。
```
## 7.0 懒执行
```
懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某
些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一
般可以通过定时器或者事件的调用来唤醒。
```
## 8.0 懒加载
```

懒加载就是将不关键的资源延后加载。</p>
<p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可
视区域）内需要加载的东西。对于图片来说，先设置图片标签的 &#39;src&#39; 属性为
一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，
就将自定义属性替换为 &#39;src&#39; 属性，这样图片就会去下载资源，实现了图片懒
加载。</p>
<p>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始
播放视频等等。

```
## 9.0 图片优化
```

计算图片大小</p>
<p>对于一张 100 <em> 100 像素的图片来说，图像上有 10000 个像素点，如果每个
像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1
 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000 </em> 1 * 4 
 / 1024）。</p>
<p>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过
减少每个像素的调色板来相应缩小图片的大小。</p>
<p>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个
思路了：</p>
<p>减少像素点
减少每个像素点能够显示的颜色</p>
<p>图片加载优化</p>
<p>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用
 CSS 去代替。
对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一
般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图
片。
小图使用 base64 格式
将多个图标文件整合到一张图片中（雪碧图）
选择正确的图片格式：
   对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式
   具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无
   差异的图像质量，缺点就是兼容性并不好
   小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   照片使用 JPEG

```
## 10.0 其他文件优化
```
CSS 文件放在 &#39;head&#39; 中
服务端开启文件压缩功能
将 &#39;script&#39; 标签放在 &#39;body&#39; 底部，因为 JS 文件执行会阻塞渲染。当然也
可以把 &#39;script&#39; 标签放在任意位置然后加上 &#39;defer&#39; ，表示该文件会并行下
载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加
上 &#39;async&#39; ，表示加载和渲染后续文档元素的过程将和  JS 文件的加载与执行并
行无序进行。
执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 
&#39;Webworker&#39;。&#39;Webworker&#39; 可以让我们另开一个线程执行脚本而不影响渲染。
```
## 11.0 CDN
```
静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑
使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，
否则每次请求都会带上主站的 Cookie。
```
## 12.0 使用 Webpack 优化项目
```
对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩
使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码
优化图片，对于小图可以使用 base64 的方式写入文件中
按照路由拆分代码，实现按需加载
给打包出来的文件名添加哈希，实现浏览器缓存文件
```
## 13.0 监控
```

对于代码运行错误，通常的办法是使用 &#39;window.onerror&#39; 拦截报错。该方法能
拦截到大部分的详细报错信息，但是也有例外</p>
<p>对于跨域的代码运行错误会显示 &#39;Script error.&#39; 对于这种情况我们需要给
 &#39;script&#39; 标签添加 &#39;crossorigin&#39; 属性
对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 
&#39;arguments.callee.caller&#39; 来做栈递归</p>
<p>对于异步代码来说，可以使用 &#39;catch&#39; 的方式捕获错误。比如 &#39;Promise&#39; 可以
直接使用 &#39;catch&#39; 函数，&#39;async await&#39; 可以使用 &#39;try catch&#39;</p>
<p>但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便
于 debug。</p>
<p>对于捕获的错误需要上传给服务器，通常可以通过 &#39;img&#39; 标签的 &#39;src&#39; 发起一个
请求。

```
## 14.0 面试题
```

如何渲染几万条数据并不卡住界面**</p>
<p>这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条
都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 
&#39;requestAnimationFrame&#39; 来每 16 ms 刷新一次。</p>
<p>html
&lt;!DOCTYPE html&gt;</p>
<html lang="en">

<p><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head></p>
<p><body>
  <ul>控件</ul>
  <script>
    setTimeout(() =&gt; {
      // 插入十万条数据
      const total = 100000
      // 一次插入 20 条，如果觉得性能不好就减少
      const once = 20
      // 渲染数据总共需要几次
      const loopCount = total / once
      let countOfRender = 0
      let ul = document.querySelector(&quot;ul&quot;);
      function add() {
        // 优化性能，插入不会造成回流
        const fragment = document.createDocumentFragment();
        for (let i = 0; i &lt; once; i++) {
          const li = document.createElement(&quot;li&quot;);
          li.innerText = Math.floor(Math.random() * total);
          fragment.appendChild(li);
        }
        ul.appendChild(fragment);
        countOfRender += 1;
        loop();
      }
      function loop() {
        if (countOfRender &lt; loopCount) {
          window.requestAnimationFrame(add);
        }
      }
      loop();
    }, 0);
  </script>
</body>
</html>

```
## 15.9 御修了ありがとうございました。
* certificatePath: https://firebasestorage.googleapis.com/v0/b/wohapp-3a179.appspot.com/o/knowledgecontents%2FiHmcxnnRDWPOJAE38On1nCdq0ir2%2F-LdLtaiBADqiIat-6k_cx15?alt=media&token=b0bc9e21-dd26-4e3f-b2fb-01638c512c70
