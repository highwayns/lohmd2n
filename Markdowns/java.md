JAVA入門
===
* knowledgeid: -LdLtaiBADqiIat-6k_9
* author: tei952
* authorid: iHmcxnnRDWPOJAE38On1nCdq0ir2


## 1.0 Java 開発環境
```
Java の世界へようこそ！ ここでは Java を用いたプログラミングに必要な、
開発環境の整備をします。 
```

## 2.0 Java とは
```
Java はオブジェクト指向のプログラミング言語です。 
他のオブジェクト指向言語を習得している方はお分かりと思います。プログラ
ミングが始めて、あるいは、 オブジェクト指向というのは良くわからない、
という方にはこのサイトで後で説明しますので、そちらをお読みください。 
C 言語の「ポインタ」のように、柔軟だけれど危険でわかりにくい、といった
要素を排除するなどされています。 Java はわかり易い言語仕様で、学習し易
いといわれています。 
```

## 3.0 JDK のダウンロードとインストール
```
Java の開発をするには Java Development Kit (JDK) を入手します。 
Java のダウンロードサイトから、Java SE Development Kit (JDK) 6 をダ
ウンロードします。 
私の環境は Windows 7 の 32 bit の環境だったのですが、JDK のダウンロー
ドファイル名は jdk-6u19-windows-i586.exe でした。これは 「JDK バージョ
ン 1.6 の Update 19。Windows の i586 用」 という意味になります。 
パッケージをダブルクリックして、インストールを開始すれば OK です。 
このとき、念のためインストール先ディレクトリは変な問題が起きないように、 
C:\jdk\1.6.0_19 のように空白を含まないパスにしておいたほうが良いようです。 
```
## 4.0  Eclipse のインストール
```
Eclipse のダウンロードサイト から Eclipse IDE for Java Developers を
ダウンロードします。 
zip ファイルを展開してできる、eclipse ディレクトリを C:\eclipse などに
配置すればそれで完了です。 
その中の eclipse.exe をダブルクリックすれば Eclipse の IDE が起動します。 
ただ、これだけです。簡単ですね。 
```

## 5.0 便利な Eclipse ショートカット集
```
プログラミング中はなるべくキーボードから手を離さずに、様々な動作ができた方が
効率が良いことが多いです。 Eclipse にも多数のショートカットキーがデフォルト
で割り当てられています。 ショートカットは数あれど、ここではその中で、特に便
利なショートカットキーを紹介します。
編集タブの移動 : Ctrl + E
元の場所に戻る・進む : Alt + ← または →
対応する括弧を行き来する : Ctrl + Shift + P
行のコメントアウト : Ctrl + /
複数行のコメントアウト : Ctrl + Shift + /
フォーマット : Ctrl + Shift + F
クイックフィックス : Ctrl + 1
型の階層表示 : F4
型の検索ボックス表示 : Ctrl + Shift + T
コードのアウトライン表示 : Ctrl + O
アウトラインを上下に移動 : Ctrl + Shift + ↑ または ↓
検索画面の表示 : Ctrl + F
ファイルを閉じる : Ctrl + W
ファイルを保存 : Ctrl + S
ショートカットの表示 : Ctrl + Shift + L
```

## 6.0 Tomcat のインストール
```
Java で Web アプリケーションを開発する場合は、Java を実行するアプリケー
ションサーバーが必要になります。 
Tomcat は Apache.org が開発している Java Servlet/JSP の実行環境で、Java 
のアプリケーションサーバーとして広く使われています。 ここでは、Tomcat の
インストールを行い、さらに Eclipse から Tomcat を利用するためのプラグイ
ンの設定も行います。 
```

## 7.0 JAVAプログラムを動かそう
```
public class HelloJava {

     public static void main(String[] args) {

          System.out.println( "Hello, world!" );     
     
     }
     
}
この内容を HelloJava.java というファイル名で保存してください。 ファイル名
はそのコードのクラス名で名前をつけます。 
このプログラムでは、"Hello, world!" という文字を標準出力に出力します。その
ために System.out.println というメソッドを呼び出していますが、 よくわから
ないという方は、ここでは「画面に文字を出すときには System.out.println を使
う」 と覚えておけば十分です。 
次にコマンドプロンプトを開いて、コマンドラインからコンパイルしてみましょう。 
コンパイルコマンドは javac です。javac に対して、次のように HelloJava.java 
というファイル名を渡します。 
```

## 8.0 変数
```
データ型  意味  既定値
byte     ８ビットの符号付整数
         -128 から 127 までを表します。 0
short    １６ビットの符号付整数
         -32,768 から 32,767 までを表します。0
int      ３２ビットの符号付整数
         -2,147,483,648 から 2,147,483,647 までを表します 0
long     ６４ビットの符号付整数
         -9,223,372,036,854,775,808 から 9,223,372,036,854,775,807 まで
         を表します 0L
float   ３２ビットの浮動小数点値  0.0f
double  ６４ビットの倍精度浮動小数点値 0.0d
boolean true または false の値をとる  false
char    １６ビットの Unicode 文字
         \u0000 から \uFFFF までの値  '\u0000'
```

## 9.0 配列
```
配列
配列 (array) とは、同じデータ型のデータを複数格納するコンテナです。配列内に格納
できる要素数は固定です。 例えば、「５個の整数を格納する配列」 は次のように定義で
きます。 
int[] a;     
a = new int[5];
配列内の要素には添え字 (インデックス) でアクセスできます。 要素内の１番目の要素
はインデックス [0]、２番目の要素はインデックス [1]、・・・ のように、 n 番目の
要素には [n-1] というインデックスでアクセスできます。 
次のコード例では、５個の整数を格納できる整数の配列を用意し、 それに、１番目の要
素から順に１、２、３、４、５ を格納し、 それを逆に、５、４、３、２、１ という風
に順番にその要素の中身を出力します。 
public class ArrayTest {

     public static void main(String[] args) {

          int[] a;
          
          a = new int[5];
          
          a[0] = 1;
          a[1] = 2;
          a[2] = 3;
          a[3] = 4;
          a[4] = 5;
          
          System.out.println( a[4] );
          System.out.println( a[3] );
          System.out.println( a[2] );
          System.out.println( a[1] );
          System.out.println( a[0] );
          
     }
     
}
```

## 10.0 演算子
```
足し算、引き算、掛け算、割り算などを行う演算子は次のとおりです。 
演算子  役割
+      足し算
-      引き算
*      掛け算
/      割り算
%      割り算の余り
++     1 だけインクリメント (加算) 
--
1 だけデクリメント (減算) 
さっそく、この実行例を示します。 
public class OpTest1 {

     public static void main(String[] args) {

          System.out.println( 10 + 5 );
          System.out.println( 10 - 5 );
          System.out.println( 2 * 3 );
          System.out.println( 10 / 2 );
          System.out.println( 10 % 3 );
                    
     }
     
}
```

## 11.0 処理の分岐
```
if 文
if 文では、条件が真 (true) と評価されるときに実行するコードブロック、
偽 (false) のときに実行するコードブロックを指定することができます。 
if( 条件文1 ) {
     // 条件文1 が真 (true) のときにここが実行される
}
else {
     // 条件文1 が偽 (false) のときにここが実行される
}
条件は複数あっても構いません。その場合は else if (条件文2) として記述
します。 また、else ブロックは任意です。 
実行例は次のとおりです。 
public class ControlFlow1 {

     public static void main(String[] args) {

          int i = 68;
          
          if( 80 < i ) {
               System.out.println( "A" );
          } else if( 60 < i ) {
               System.out.println( "B" );
          } else {
               System.out.println( "C" );
          }
          
     }
     
}
```

## 12.0 クラス定義とオブジェクト
```
最も基本的なクラス定義は次のようになります。 
class クラス名 {
     // ここにフィールド、コンストラクタ、メソッドを書く
}
継承するクラス、実装するインターフェイスがある場合は次のように書きます。 
class クラス名 extends スーパークラス implements インターフェイス {
     // ここにフィールド、コンストラクタ、メソッドを書く
}
スパークラスはひとつだけ指定できます。インターフェイスはカンマで区切り
複数指定できます。 
それでは、具体的な例として「人」を表す Person クラスというのを実装して
みましょう。 
public class Person {

     // フィールド
     private int age;
     private String name;
     
     // コンストラクタ
     public Person( int a, String n ) {
          age = a;
          name = n;
     }
     
     public void setAge( int a ) {
          age = a;
     }
     
     public void setName( String n ) {
          name = n;
     }
     
     public int getAge() {
          return age;
     }
     
     public String getName() {
          return name;
     }
     
}
```

## 13.0 コンストラクタ
```
コンストラクタはクラスのオブジェクトを生成するときに呼ばれる特別な
メソッドです。 コンストラクタにパラメータを渡すことで、オブジェク
ト生成時にオブジェクトを初期化できます。 
さらに、Person クラスを継承して従業員 (Employee) クラスを定義しま
しょう。 従業員クラスには従業員 ID という属性を持たせましょう。 
public class Employee extends Person {

     private int employeeID;

     public Employee( int a, String n, int eid ) {
          super( a, n );
          employeeID = eid;
     }

     public void setEmployeeID( int eid ) {
          employeeID = eid;
     }

     public int getEmployeeID() {
          return employeeID;
     }

}
```

## 14.0 オブジェクトの生成
```
クラスのインスタンス (オブジェクト) を作成するには new キーワード
を使います。 
クラス名 変数名 = new クラス名 (コンストラクタへのパラメータ);
Employee クラスを利用するテストプログラムを作成します。 
public class EmployeeTestApp1 {

     public static void main(String[] args) {

          Employee p = new Employee( 20, "Ichiro Suzuki", 100 );

          System.out.println( p.getAge() );
          System.out.println( p.getName() );
          System.out.println( p.getEmployeeID() );

     }

}
```

## 15.0 コピーとクローンの問題点
```
オブジェクトのコピーを作る時には、そのオブジェクトが持つ参照に注意が
必要です。 
次のコードを見てください。 
Person p1 = new Person();
Person p2 = p1;
    
p1.setAge(30);
この例では Person クラスのオブジェクト p1 が p2 に代入されています。 
このようにすると、p2 は p1 が指しているオブジェクトと全く同じオブジ
ェクトを指し示します。 すると、p1 に行った変更が p2 にも影響すること
になります。（実体は全く同じものですから当然ですね） 
clone メソッドの利用
他の変数に対して行った操作の影響を避けるためには、clone メソッドを利
用します。 
clone メソッドは Object クラスにて定義されており、二つのオブジェクト
をフィールド毎に値を丸コピーします。 
上のコード例の p1 と p2 が互いに変更の影響を受け合わないようにするに
は、clone メソッドを用いて次のようにします。 
Person p1 = new Person();
Person p2 = p1.clone();
    
p1.setAge(30);
```

## 16.0 Cloneable インターフェイスと clone メソッドの定義
```
上術のようなオブジェクトのコピー・クローンの問題を解決するには、
Cloneable インターフェイスを実装し clone メソッドを定義し直します。 
public class Person implements Cloneable {
  Class1 o;
  ...
  
  public Person clone() throws CloneNotSupportedException {
    Person cloned = (Person) super.clone();
    cloned.o = (Class1) o.clone();
    return cloned;
  }
}

public class Class1 implements Cloneable {
  ...

  public Class1 clone() throws CloneNotSupportedException {
    return (Class1) super.clone();
  }
}
```

## 17.0 匿名内部クラス
```
次の場面では、クラスに名前をつけること無くクラスを定義してインスタ
ンスを生成する事が可能です。 
あるクラスの派生クラスのオブジェクトを一つだけインスタンス化する場合 
あるインターフェイスを実装して一つだけインスタンスを作成する場合 
名前を付けずにクラスを定義するので、このようなクラスを匿名内部クラス
 (Anonymous Inner Class) といいます。 
匿名内部クラスの書き方は、次のようになります。 
new スーパータイプ ( コンストラクタ パラメータ) {
  インナークラスのメソッド、データ
}
```

## 18.0 文字列 (String)
```
String は Java で文字列をあらわす基本的なクラスです。基本的な、といっ
てもプリミティブな変数として「文字列」という型があるわけではなく、 Java
 の標準ライブラリとして String クラスが用意されているということになります。 
Java でいう「文字列」は Unicode 文字が並んだものです。文字列の定数は " 
(二重引用符) で囲みます。例えば Hello と書きたければ、"Hello" のように二
重引用符で囲みます。 "Hello" と書いた場合は、H、e、l、l、o という Unicode
 文字が連続したものです。 
また、Unicode の文字コードを直接指定することもできます。 
例えば次のように ☺ 記号を表す \u263A を直接入力することもできます。 
public class StringTestApp1 {
  public static void main(String[] args) {
    System.out.println("Hello\u2606");
  }
}
```

## 19.0 文字列操作
```
以下は文字列操作のコードとその実行例です。 
public class StringTest1 {

     public static void main(String[] args) {

          // 単純な String の出力
          String s1 = "Hello!";

          System.out.println( s1 );

          // char の配列から String を作る
          char[] c = { 'H', 'e', 'l', 'l', 'o', '!' };
          String s2 = new String( c );

          System.out.println( s2 );

          // 文字の結合
          String s3 = s1.concat( s2 );

          System.out.println( s3 );

          // 文字列を結合する時に + 演算子を使う
          System.out.println( s1 + " - " + s2 );

          // 長さ
          System.out.println( s1.length() );

     }

}
```

## 20.0 Java の正規表現 
```
しかし最初に言うのもなんですが、正規表現自体が非常に奥の深いもので、それだけ
で本一冊できてしまうボリュームがあるテーマです。
従って完全に網羅しているわけでないことはあらかじめお断りしておきます。
その代わり、Java で正規表現を利用するはじめの一歩、取っ掛かりとして役に立つ
項目を取り上げました。
Java の正規表現 (Regular Expression) の基礎
ここでは Java で正規表現を利用するための基礎的なメソッドおよびそれの注意事項
について説明します。 
グルーピングで文字を抜き出す
マッチした箇所から特定の文字を抜き出すのに便利なグルーピングについて説明します。 
正規表現による文字列のスプリット
文字列への適用例として、正規表現を使って文字列をスプリットする例を紹介します。 
正規表現による文字列の置換
文字列への正規表現の適用例として、マッチした箇所の文字の置換方法を紹介します。 
```

## 21.0 例外オブジェクト
```
例外オブジェクト
Java の例外オブジェクトは全て、java.lang.Throwable から派生します。 Error、
Exception 等です。 
try-catch-finally ブロック
例外処理の形式は次のとおりです。 
try {

     // try ブロック

} catch (例外型１ e) {

     // 例外処理

} catch (例外型２ e) {

...

} finally {

     // 常に実行される

}
```

## 22.0 リフレクション
```
実行時においてオブジェクトのクラス情報を調べたりすることを、リフレクションといい
ます。リフレクションによって、 実行時にクラスの名前、メソッドの名前やパラメータ
などを知ることができます。 
Class クラスとは？
Java の実行環境はそれぞれのオブジェクトの型情報を常に判別しています。ここではそ
のことに関わる Class クラスについて説明します。 
オブジェクトに関連する Class オブジェクトの取得
Class オブジェクトの取得方法の一つを、具体例を交えて紹介します。 
クラス名からの Class オブジェクトの取得
Class オブジェクトのもう一つの取得方法について説明します。 
Class オブジェクトからのインスタンスの作成
ここでは Class オブジェクトから、それが表す型のインスタンスを作成する方法をしめ
します。
Class オブジェクトからのインスタンスの作成とメソッド呼出し
```

## 23.0 パッケージ
```
パッケージの命名
パッケージは通常次のようなルールで命名します。 
全て小文字とする 
インターネットのドメイン名の逆にしたものをプレフィックスにする
例. ドメイン名が java.keicode.com ならばプレフィックスは com.keicode.java 
ただし、ハイフン等の記号、数字始まり、 Java のキーワード (int 等) を含む場合は _ 
(アンダースコア) をつける
例. 1foo.com → com._1foo
hawaii.nokoto.site → com.hajimete_hawaii 
パッケージの作成
パッケージ名はソースファイルの一行目に package キーワードを用いて、パッケージ名
を指定します。 
package パッケージ名;
```

## 24.0 ジェネリックス
```
ジェネリックス (Generics) というのは汎用的なクラスやメソッドを特定の型に対応づけ
る機能のことで、Java SE5.0 から導入されました。 
いい例えかどうか分かりませんが、例えば「食べ物コンテナ」という汎用的なコンテナを
作ったときに、 それを「ラーメンコンテナ」「カレーコンテナ」という風に特定の型にき
ちっと決めるものです。 
それがなぜいいのか？どうやって作るのか？どうやって使うのか？ということをみていき
たいと思います。 
ジェネリックスとは？なぜジェネリックスなのか
ジェネリックスを導入する意図、それがないときの問題点について説明します。
ジェネリックスの名前付け
サブタイプ
ジェネリックスメソッドとコンストラクタ
境界型 (Bounded Types)
ワイルドカード
<? extends クラス名> という意味について説明します。
スーパータイプ バウンド
こちらは <? super クラス名> について説明します。また図で理解を深めましょう。
```

## 25.0 日時・タイムゾーンの扱い
```
ava では日付、時間およびタイムゾーンを扱うための便利なクラス、ライブラリが用意さ
れています。 
日本ではタイムゾーンはひとつだけなので、日本限定のプログラムであればあまりタイム
ゾーンを意識しなくても、 ローカル時間を使えば通常は問題ありません。しかし、例えば
アメリカなどの複数のタイムゾーンが使われている国でも使えるように拡張しようと思え
ば、たちまちタイムゾーンは深刻な問題となります。 
タイムゾーンの使い方
ここでは利用可能な TimeZone の列挙方法、タイムゾーン ID についてみていきます。 
カレンダーとタイムゾーンの利用
カレンダー (java.util.Calendar) とタイムゾーン (java.util.TimeZone) を利用
する具体的な方法を紹介します。
```

## 26.0 Web アプリケーションの開発
```
開発環境として、Eclipse と Tomcat を利用することを前提としますので、インストール
していない方は、 Tomcat をインストール してください。 
Web アプリケーションの動作確認 (Tomcat プロジェクト)
Tomcat プロジェクトを作って、JSP およびサーブレットの簡単な動作確認を行います。 
サーブレットから JDBC を利用する
サーブレットから MySQL に JDBC で接続してクエリを実行する具体例を示します。 
JSP/Servlet フィルターの基本
JSP/サーブレットフィルタの基本的な開発、設定方法を示します。 
JSP
JSP の事前定義変数 - 暗黙オブジェクト 
設定
ウェルカムページ (デフォルトページ) の設定 
JSP/Servlet フィルターの登録
JSP/Servlet フィルターのページで登録方法も示しています。 
```

## 27.0 マルチスレッド
```
マルチスレッド・プログラミングは、うまいコードを書くのがもっとも難しいものの一つ
といってよいでしょう。
ちょっと間違えてスレッドセーフではないコードを書いてしまえば、あっという間にデータ
が壊れるか、 あるいはテスト環境ではうまく動いていたのに、本番の環境で時々つかみ所
のないような形でバグがちょろちょろと顔を出してきます。
ここではそんな、 Java のマルチスレッド・プログラミングの基本的な事柄について説明
します。
Java のマルチスレッド・プログラミングの基本
どんなときに複数のスレッドで処理を行うべきなのか、そしてそれはどのように行うのか、
ということについて簡単に説明します。 
ExecutorService の基本的な使い方、考え方
スレッドプールを簡単に利用する方法として、ExecutorService があります。 Executor
Service の基本的な仕組みと利用方法について説明します。 
処理のキャンセル、中断
ExecutorService で処理しているタスクを途中でキャンセルするにはどうしたらよいで
しょうか。
```

## 28.0 基本的な I/O
```
これまで C 言語などでプログラミングをしてきた人は、きっとファイルを操作しようとして
 FILE* などがないことに驚くかもしれません。
Java ではファイルやソケットなどの入出力は、入力ストリーム (Input Stream)、あるいは、
出力ストリーム (Output Stream) として扱います。 読み込む元が入力ストリームで、書き
出す先が出力ストリームです。
そしてそのストリームに対して、リーダー (Reader) やライター (Writer) が用意されてい
ます。
これの優れているところは、ストリーム (読み込み元や書き出す先) が必ずしも伝統的なファ
イルハンドル (ファイル、ソケット、パイプ等) と限らず、 メモリ上の単純なバイト列だった
り、あるいは別のストリームであったりするところがあげられます。
こうすることによってデータの入出力が、それがファイルであろうとメモリブロックであろうと
、同様に扱えるようになるわけです。 また、多機能なストリームを数珠つなぎにすることによっ
て、各種データをバッファリングしたり、GZIP したりできます。
ここではテキストファイルやバイナリファイルの入出力を行うことによって、基本的なストリー
ムやリーダー・ライターの使い方を見ていきます。
テキストファイルの読み込みと書き込み 
バイナリファイルの読み込みと書き込み 
オブジェクトのシリアライズとデシリアライズ 
ソケットの読み込みと書き込み 
```

## 29.0 New I/O (java.nio)
```
NIO は java.nio パッケージで提供されます。 これは低レベル I/O を極力サポートして、 
プラットフォームに合わせてより効率的に I/O 操作ができることを目的としています。
ここでは NIO の具体的な利用方法をみていきましょう。
NIO Buffer の使い方
例えば OpenGL ES ライブラリを利用する時等にも、 NIO Buffer は利用されます。ここでは
具体的な利用例と、それぞれのコードの意味について考えていきます。 バイトオーダー、ビュ
ーバッファなどの説明も。 
```

## 30.0 Java アプレット
```
Java アプレット (Java applet) はウェブページに埋め込んだ形で実行可能なアプリケーショ
ンのことです。
HTML ページに関連付けされたアプレットは、HTML や画像などと同じように自動的にダウンロー
ドされて実行され、 特に１９９０年台後半にインタラクティブなウェブページを実装するのに広
く使われました。
その後、JavaVM 自体の配布の問題やら、代替テクノロジ (Java Web Start) の出現などで、当
時のような人気はなくなったものの、 環境さえ整えば有効に利用できることに変わりはありません。
```

## 31.0 Swing による GUI
```
Swing とは？ 
最も単純なフレームの表示
単純なフレームの表示方法を示します。 
フレームの基本的な設定
フレームの位置、タイトルなどの基本的な設定方法を示します。 
ルックアンドフィールの設定
トップレベルコンテナー
Swing のコンポーネント 
JComponent > AbstractButton 
ボタン JButton
チェックボックス JCheckBox
ラジオボタン 
ラジオボタン JRadioButton
ラジオボタングループのタイトルと枠線の表示
コンボボックス JComboBox の使い方
レイアウトの基礎 
FlowLayout (フローレイアウト) の基礎
等間隔のマス目に並べる GridLayout (グリッドレイアウト)
BorderLayout (ボーダーレイアウト) 
BoxLayout (ボックスレイアウト) 
CardLayout (カードレイアウト)
タブ表示 
タブ表示 JTabbedPane の使い方
JTabbedPane のタブ切り替えイベント
イベント処理の基本 （委譲イベントモデル） 
```

## 32.0 JTable の使い方
```
一般的な業務で使われるシステムの目的は、結局のところ構造化されたデータを操作する
ことがメインであることがほとんどと言ってよいでしょう。
在庫データ、発注データ、販売データ、ナントカデータと、あげればキリがありません。
カメラアプリなどのように 「一発撮ってファイルに落として、ハイ終了」、というのは
むしろレアケースです。
特に標準的な RDBMS に保存される表組みデータを扱うにはグリッドコンポーネントが欠
かせません。 グリッドとか、表組みとか、呼び名はいろいろあれど要は表組みです。
Swing ではこれを JTable コンポーネントで行います。
JTable の簡単な使い方
JTable でデータとビューをつなぐテーブルモデル
JTable でのデータの表示方法を決める セルレンダラー
デフォルトセルレンダラーを使って中央揃えにする方法
カスタムのセルレンダラーを作りセルの値によって背景色を変更する方法
JTable のセルの値を更新するテーブルモデルの実装方法
JTable のセルに編集用のドロップダウンを設定する方法
JTable での単純なソート（並べ替え）
JTable でデータフィルターを実装する方法
JTable に行を追加する
単純に表示をすれば良い場合から、テーブル内でドロップダウンを表示してデータ編集を行う
とか、行を追加するとか、いろいろな使用レベルがあります。
無駄に複雑なコードにしなくていいように、ここでは順を追って少しずつ複雑な形にしていき
ながら説明しています。
```

## 33.0 コレクション
```
Java のコレクションインターフェイスは主に次のものが挙げられます。 
List - 要素が順番に並んだものを扱う 
Map - キーと値のペアを扱う 
Queue と Deque - 順番に入れたものを順番に取り出す方式のデータ構造を扱う 
Set - 順番は問わないが各要素へアクセス可能としたいとき 
データ構造についてあまり知らない人は、あまりピンとこないかもしれませんので、不安の
ある人はデータ構造・アルゴリズムに関する文献等でリスト、キュー・・・などの基本的な
考え方を学んでおいてください。 
Java のコレクション・クラスライブラリでは、これらのインターフェイスを実装した各種
クラスがあり、状況に応じて適切なクラスを利用することが可能です。 
具体例をみてみましょう。 
List インターフェイスと ArrayList 
キー・バリューペアを保持する Map の基礎 - HashMap、Hashtable、TreeMap 
ArrayList 要素のソートと Comparator
HashSet と TreeSet はどう使う？
状況によって、望ましい実装は変わります。（その詳細はデータ構造・アルゴリズムの教科書
を読んでください） 
実装は変わっても、概念的に同系統のものであれば、 それを利用する具体的な方法（コード）
は統一された方法になる・・・。これがインターフェイスと実装を切り離す利点です。 
```

## 34.0 XML
```
XML はテキストファイルでデータ交換をするためのデータフォーマットとして、現在の主流の
データ形式といってよいでしょう。 テキスト形式で要素間の階層構造、属性が人間にもわかり易
く定義され、また、様々な言語での解析用、要素操作用のライブラリが揃っています。 
ここでは、Java で XML 操作をするときの基本的な方法をみていきましょう。 
XML を読み込む 
XmlPull を利用した XML の解析 - kXML 
```
## 35.9 御修了ありがとうございました。
* certificatePath: https://firebasestorage.googleapis.com/v0/b/wohapp-3a179.appspot.com/o/knowledgecontents%2FiHmcxnnRDWPOJAE38On1nCdq0ir2%2F-LdLtaiBADqiIat-6k_9x36?alt=media&token=ae597a39-1bcc-4937-aa0f-aff181084db8
