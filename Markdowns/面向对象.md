面向对象
===
* knowledgeid: -LdLtaiBADqiIat-6k_37
* author: tei952
* authorid: iHmcxnnRDWPOJAE38On1nCdq0ir2

## 1.0 三大特性
```

封装</p>
<p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点：</p>
<p> 减少耦合：可以独立地开发、测试、优化、使用、理解和修改
 减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块
 有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能
 提高软件的可重用性
 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</p>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<p>java
public class Person {</p>
private String name;
private int gender;
private int age;

public String getName() {
    return name;
}

public String getGender() {
    return gender == 0 ? &quot;man&quot; : &quot;woman&quot;;
}

public void work() {
    if (18 &lt;= age &amp;&amp; age &lt;= 50) {
        System.out.println(name + &quot; is working very hard!&quot;);
    } else {
        System.out.println(name + &quot; can&#39;t work any more!&quot;);
    }
}
<p>}</p>
<p>继承</p>
<p>继承实现了  <strong>IS-A</strong>  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为  <strong>向上转型</strong> 。</p>
<p>java
Animal animal = new Cat();</p>
<p>多态</p>
<p>多态分为编译时多态和运行时多态：</p>
<p> 编译时多态主要指方法的重载
 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</p>
<p>运行时多态有三个条件：</p>
<p> 继承
 覆盖（重写）
 向上转型</p>
<p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p>
<p>java
public class Instrument {</p>
public void play() {
    System.out.println(&quot;Instument is playing...&quot;);
}
<p>}</p>
<p>public class Wind extends Instrument {</p>
public void play() {
    System.out.println(&quot;Wind is playing...&quot;);
}
<p>}</p>
<p>public class Percussion extends Instrument {</p>
public void play() {
    System.out.println(&quot;Percussion is playing...&quot;);
}
<p>}</p>
<p>public class Music {</p>
public static void main(String[] args) {
    List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;();
    instruments.add(new Wind());
    instruments.add(new Percussion());
    for(Instrument instrument : instruments) {
        instrument.play();
    }
}
<p>}

```
## 2.0 类图
```

以下类图使用 <a href="https://www.planttext.com/">PlantUML</a> 绘制，更多语法及使用请参考：http://plantuml.com/ 。</p>
<p>泛化关系 (Generalization)</p>
<p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<p><div align="center"> <img src="pics/c0874e0a-dba3-467e-9c86-dd9313e0843e.jpg" width="180px"> </div><br></p>
<p>text
@startuml</p>
<p>title Generalization</p>
<p>class Vihical
class Car
class Trunck</p>
<p>Vihical &lt;|-- Car
Vihical &lt;|-- Trunck</p>
<p>@enduml

```
## 3.0 实现关系 (Realization)
```

用来实现一个接口，在 Java 中使用 implements 关键字。</p>
<p><div align="center"> <img src="pics/83d466bd-946b-4430-854a-cf7b0696d4c8.jpg" width="170px"> </div><br></p>
<p>text
@startuml</p>
<p>title Realization</p>
<p>interface MoveBehavior
class Fly
class Run</p>
<p>MoveBehavior &lt;|.. Fly
MoveBehavior &lt;|.. Run</p>
<p>@enduml

```
## 4.0 聚合关系 (Aggregation)
```

表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<p><div align="center"> <img src="pics/a0ce43b7-afa8-4397-a96e-5c12a070f2ae.jpg" width="300px"> </div><br></p>
<p>text
@startuml</p>
<p>title Aggregation</p>
<p>class Computer
class Keyboard
class Mouse
class Screen</p>
<p>Computer o-- Keyboard
Computer o-- Mouse
Computer o-- Screen</p>
<p>@enduml

```
## 5.0 组合关系 (Composition)
```

和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p>
<p><div align="center"> <img src="pics/6a88a398-c494-41f5-bb62-9f7fb811df7c.jpg" width="280px"> </div><br></p>
<p>text
@startuml</p>
<p>title Composition</p>
<p>class Company
class DepartmentA
class DepartmentB</p>
<p>Company <em>-- DepartmentA
Company </em>-- DepartmentB</p>
<p>@enduml

```
## 6.0 关联关系 (Association)
```

表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<p><div align="center"> <img src="pics/a3e4dc62-0da5-4d22-94f2-140078281812.jpg" width="200px"> </div><br></p>
<p>text
@startuml</p>
<p>title Association</p>
<p>class School
class Student</p>
<p>School &quot;1&quot; - &quot;n&quot; Student</p>
<p>@enduml

```
## 7.0 依赖关系 (Dependency)
```

和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>
<p> A 类是 B 类方法的局部变量；
 A 类是 B 类方法当中的一个参数；
 A 类向 B 类发送消息，从而影响 B 类发生变化。</p>
<p><div align="center"> <img src="pics/379444c9-f1d1-45cd-b7aa-b0c18427d388.jpg" width="330px"> </div><br></p>
<p>text
@startuml</p>
<p>title Dependency</p>
<p>class Vihicle {
    move(MoveBehavior)
}</p>
<p>interface MoveBehavior {
    move()
}</p>
<p>note &quot;MoveBehavior.move()&quot; as N</p>
<p>Vihicle ..&gt; MoveBehavior</p>
<p>Vihicle .. N</p>
<p>@enduml

```
## 8.0 设计原则
```

S.O.L.I.D</p>
<p>| 简写 | 全拼 | 中文翻译 |
| :--: | :--: | :--: |
| SRP | The Single Responsibility Principle    | 单一责任原则 |
| OCP | The Open Closed Principle              | 开放封闭原则 |
| LSP | The Liskov Substitution Principle      | 里氏替换原则 |
| ISP | The Interface Segregation Principle    | 接口分离原则 |
| DIP | The Dependency Inversion Principle     | 依赖倒置原则 |</p>
<p>单一责任原则</p>
<blockquote>
<p>修改一个类的原因应该只有一个。</p>
</blockquote>
<p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p>
<p>开放封闭原则</p>
<blockquote>
<p>类应该对扩展开放，对修改关闭。</p>
</blockquote>
<p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p>
<p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p>
<p>里氏替换原则</p>
<blockquote>
<p>子类对象必须能够替换掉所有父类对象。</p>
</blockquote>
<p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p>
<p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p>
<p>接口分离原则</p>
<blockquote>
<p>不应该强迫客户依赖于它们不用的方法。</p>
</blockquote>
<p>因此使用多个专门的接口比使用单一的总接口要好。</p>
<p>依赖倒置原则</p>
<blockquote>
<p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；</br>抽象不应该依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p>
<p>依赖于抽象意味着：</p>
<p> 任何变量都不应该持有一个指向具体类的指针或者引用；
 任何类都不应该从具体类派生；
 任何方法都不应该覆写它的任何基类中的已经实现的方法。

```
## 9.0 其他常见原则
```
`
```
## 10.9 御修了ありがとうございました。
* certificatePath: https://firebasestorage.googleapis.com/v0/b/wohapp-3a179.appspot.com/o/knowledgecontents%2FiHmcxnnRDWPOJAE38On1nCdq0ir2%2F-LdLtaiBADqiIat-6k_37x10?alt=media&token=c4c4205e-30d6-4745-9b0f-b7e5b7983b9e
