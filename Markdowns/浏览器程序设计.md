浏览器程序设计
===
* knowledgeid: -LdLtaiBADqiIat-6k_d
* author: tei952
* authorid: iHmcxnnRDWPOJAE38On1nCdq0ir2

## 1.0 事件触发三阶段
```

事件触发有三个阶段</p>
<p>  &#39;window&#39; 往事件触发处传播，遇到注册的捕获事件会触发
  传播到事件触发处时触发注册的事件
  从事件触发处往 &#39;window&#39; 传播，遇到注册的冒泡事件会触发</p>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点
同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p>
<p>js
// 以下会先打印冒泡然后是捕获
node.addEventListener(&#39;click&#39;,(event) =&gt;{
    console.log(&#39;冒泡&#39;)
},false);
node.addEventListener(&#39;click&#39;,(event) =&gt;{
    console.log(&#39;捕获 &#39;)
},true)

```
## 2.0 注册事件
```

通常我们使用 &#39;addEventListener&#39; 注册事件，该函数的第三个参数可以是布
尔值，也可以是对象。对于布尔值 &#39;useCapture&#39; 参数来说，该参数默认值为
 &#39;false&#39; 。&#39;useCapture&#39; 决定了注册的事件是捕获事件还是冒泡事件。对于对
象参数来说，可以使用以下几个属性</p>
<p>  &#39;capture&#39;，布尔值，和 &#39;useCapture&#39; 作用一样
  &#39;once&#39;，布尔值，值为 &#39;true&#39; 表示该回调只会调用一次，调用后会移除
  监听
  &#39;passive&#39;，布尔值，表示永远不会调用 &#39;preventDefault&#39; </p>
<p>一般来说，我们只希望事件只触发在目标上，这时候可以使用 &#39;stopPropagation&#39;
 来阻止事件的进一步传播。通常我们认为 &#39;stopPropagation&#39; 是用来阻止事件冒
 泡的，其实该函数也可以阻止捕获事件。&#39;stopImmediatePropagation&#39; 同样也
 能实现阻止事件，但是还能阻止该事件
目标执行别的注册事件。</p>
<p>js
node.addEventListener(&#39;click&#39;,(event) =&gt;{
    event.stopImmediatePropagation()
    console.log(&#39;冒泡&#39;)
},false);
// 点击 node 只会执行上面的函数，该函数不会执行
node.addEventListener(&#39;click&#39;,(event) =&gt; {
    console.log(&#39;捕获 &#39;)
},true)

```
## 3.0 事件代理
```

如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册
在父节点上</p>
<p>html</p>
<p><ul id="ul">
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
</ul></p>
<script>
    let ul = document.querySelector('#ul')
    ul.addEventListener('click', (event) => {
        console.log(event.target);
    })
</script>

<p>事件代理的方式相对于直接给目标注册事件来说，有以下优点</p>
<p>  节省内存
  不需要给子节点注销事件

```
## 4.0 跨域
```

因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有
一个不同就是跨域，Ajax 请求会失败。</p>
<p>我们可以通过以下几种常用方法解决跨域的问题

```
## 5.0 JSONP
```

JSONP 的原理很简单，就是利用 &#39;<script>&#39; 标签没有跨域限制的漏洞。通过
 &#39;<script>&#39; 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需
 要通讯时。</p>
<p>js</p>
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
    function jsonp(data) {
        console.log(data)
    }
</script>    


<p>JSONP 使用简单且兼容性不错，但是只限于 &#39;get&#39; 请求。</p>
<p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自
己封装一个 JSONP，以下是简单实现</p>
<p>js
function jsonp(url, jsonpCallback, success) {
  let script = document.createElement(&quot;script&quot;);
  script.src = url;
  script.async = true;
  script.type = &quot;text/javascript&quot;;
  window[jsonpCallback] = function(data) {
    success &amp;&amp; success(data);
  };
  document.body.appendChild(script);
}
jsonp(
  &quot;http://xxx&quot;,
  &quot;callback&quot;,
  function(value) {
    console.log(value);
  }
);

```
## 6.0 CORS
```

CORS需要浏览器和后端同时支持。IE 8 和 9 需要通过 &#39;XDomainRequest&#39; 
来实现。</p>
<p>浏览器会自动进行 CORS 通信，实现CORS通信的关键是后端。只要后端实现了 
CORS，就实现了跨域。</p>
<p>服务端设置 &#39;Access-Control-Allow-Origin&#39; 就可以开启 CORS。 该属性
表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

```
## 7.0 document.domain
```

该方式只能用于二级域名相同的情况下，比如 &#39;a.test.com&#39; 和 &#39;b.test.com&#39;
 适用于该方式。</p>
<p>只需要给页面添加 &#39;document.domain = &#39;test.com&#39;&#39; 表示二级域名都相同
就可以实现跨域

```
## 8.0 postMessage
```

这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一
个页面判断来源并接收消息</p>
<p>js
// 发送消息端
window.parent.postMessage(&#39;message&#39;, &#39;http://test.com&#39;);
// 接收消息端
var mc = new MessageChannel();
mc.addEventListener(&#39;message&#39;, (event) =&gt; {
    var origin = event.origin || event.originalEvent.origin; 
    if (origin === &#39;http://test.com&#39;) {
        console.log(&#39;验证通过&#39;)
    }
});

```
## 9.0 Event loop
```

众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互
而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能
会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读
写锁解决这个问题。</p>
<p>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。
如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦
执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行
栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p>
<p>js
console.log(&#39;script start&#39;);</p>
<p>setTimeout(function() {
  console.log(&#39;setTimeout&#39;);
}, 0);</p>
<p>console.log(&#39;script end&#39;);</p>
<p>以上代码虽然 &#39;setTimeout&#39; 延时为 0，其实还是异步。这是因为 HTML5 标准
规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 &#39;setTimeout&#39;
 还是会在 &#39;script end&#39; 之后打印。</p>
<p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务
（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 
&#39;jobs&#39;，macrotask 称为 &#39;task&#39;。</p>
<p>js
console.log(&#39;script start&#39;);</p>
<p>setTimeout(function() {
  console.log(&#39;setTimeout&#39;);
}, 0);</p>
<p>new Promise((resolve) =&gt; {
    console.log(&#39;Promise&#39;)
    resolve()
}).then(function() {
  console.log(&#39;promise1&#39;);
}).then(function() {
  console.log(&#39;promise2&#39;);
});</p>
<p>console.log(&#39;script end&#39;);
// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</p>
<p>以上代码虽然 &#39;setTimeout&#39; 写在 &#39;Promise&#39; 之前，但是因为 &#39;Promise&#39; 
属于微任务而 &#39;setTimeout&#39; 属于宏任务，所以会有以上的打印。</p>
<p>微任务包括 &#39;process.nextTick&#39; ，&#39;promise&#39; ，&#39;Object.observe&#39; ，&#39;MutationObserver&#39;</p>
<p>宏任务包括 &#39;script&#39; ， &#39;setTimeout&#39; ，&#39;setInterval&#39; ，&#39;setImmediate&#39; ，&#39;I/O&#39; ，&#39;UI rendering&#39;</p>
<p>很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括
了 &#39;script&#39; ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行
微任务。</p>
<p>所以正确的一次 Event loop 顺序是这样的</p>
<ol>
<li>执行同步代码，这属于宏任务</li>
<li>执行栈为空，查询是否有微任务需要执行</li>
<li>执行所有微任务</li>
<li>必要的话渲染 UI</li>
<li>然后开始下一轮 Event loop，执行宏任务中的异步代码</li>
</ol>
<p>通过上述的  Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并
且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任
务中。

```
## 10.0 Node 中的 Event loop
```

Node 中的 Event loop 和浏览器中的不相同。</p>
<p>Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行</p>
<p>┌───────────────────────┐
┌─&gt;│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │&lt;──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘

```
## 11.0 timer
```

timers 阶段会执行 &#39;setTimeout&#39; 和 &#39;setInterval&#39;</p>
<p>一个 &#39;timer&#39; 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回
调，可能会因为系统正在执行别的事务而延迟。</p>
<p>下限的时间有一个范围：&#39;[1, 2147483647]&#39; ，如果设定的时间不在这个范围
，将被设置为1。

```
## 12.0 I/O
```

I/O 阶段会执行除了 close 事件，定时器和 &#39;setImmediate&#39; 的回调</p>
<p>idle, prepare </p>
<p>idle, prepare 阶段内部实现</p>
<p>poll </p>
<p>poll 阶段很重要，这一阶段中，系统会做两件事情</p>
<ol>
<li>执行到点的定时器</li>
<li>执行 poll 队列中的事件</li>
</ol>
<p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p>
<p>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系
统限制
如果 poll 队列为空，会有两件事发生
  如果有 &#39;setImmediate&#39; 需要执行，poll 阶段会停止并且进入到 check 
  阶段执行 &#39;setImmediate&#39;
  如果没有 &#39;setImmediate&#39; 需要执行，会等待回调被加入到队列中并立即
  执行回调</p>
<p>如果有别的定时器需要被执行，会回到 timer 阶段执行回调。</p>
<p>check</p>
<p>check 阶段执行 &#39;setImmediate&#39; </p>
<p>close callbacks</p>
<p>close callbacks 阶段执行 close 事件</p>
<p>并且在 Node 中，有些情况下的定时器执行顺序是随机的</p>
<p>js
setTimeout(() =&gt; {
    console.log(&#39;setTimeout&#39;);
}, 0);
setImmediate(() =&gt; {
    console.log(&#39;setImmediate&#39;);
})
// 这里可能会输出 setTimeout，setImmediate
// 可能也会相反的输出，这取决于性能
// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate
// 否则会执行 setTimeout</p>
<p>当然在这种情况下，执行顺序是相同的</p>
<p>js
var fs = require(&#39;fs&#39;)</p>
<p>fs.readFile(__filename, () =&gt; {
    setTimeout(() =&gt; {
        console.log(&#39;timeout&#39;);
    }, 0);
    setImmediate(() =&gt; {
        console.log(&#39;immediate&#39;);
    });
});
// 因为 readFile 的回调在 poll 中执行
// 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调
// 再去 timer 阶段执行 setTimeout
// 所以以上输出一定是 setImmediate，setTimeout</p>
<p>上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成
后立即执行。</p>
<p>js
setTimeout(()=&gt;{
    console.log(&#39;timer1&#39;)</p>
Promise.resolve().then(function() {
    console.log(&#39;promise1&#39;)
})
<p>}, 0)</p>
<p>setTimeout(()=&gt;{
    console.log(&#39;timer2&#39;)</p>
Promise.resolve().then(function() {
    console.log(&#39;promise2&#39;)
})
<p>}, 0)</p>
<p>// 以上代码在浏览器和 node 中打印情况是不同的
// 浏览器中一定打印 timer1, promise1, timer2, promise2
// node 中可能打印 timer1, timer2, promise1, promise2
// 也可能打印 timer1, promise1, timer2, promise2</p>
<p>Node 中的 &#39;process.nextTick&#39; 会先于其他 microtask 执行。</p>
<p>js
setTimeout(() =&gt; {
  console.log(&quot;timer1&quot;);</p>
<p>  Promise.resolve().then(function() {
    console.log(&quot;promise1&quot;);
  });
}, 0);</p>
<p>process.nextTick(() =&gt; {
  console.log(&quot;nextTick&quot;);
});
// nextTick, timer1, promise1

```
## 13.0 存储
```

cookie，localStorage，sessionStorage，indexDB</p>
<p>|     特性     |                   cookie                   |       localStorage       | sessionStorage |         indexDB          |
| :----------: | :----------------------------------------: | :----------------------: | :------------: | :----------------------: |
| 数据生命周期 |     一般由服务器生成，可以设置过期时间     | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在 |
| 数据存储大小 |                     4K                     |            5M            |       5M       |           无限           |
| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 |          不参与          |     不参与     |          不参与          |</p>
<p>从上表可以看到，&#39;cookie&#39; 已经不建议用于存储。如果没有大量数据存储需求的
话，可以使用 &#39;localStorage&#39; 和 &#39;sessionStorage&#39; 。对于不怎么改变的数
据尽量使用 &#39;localStorage&#39; 存储，否则可以用 &#39;sessionStorage&#39; 存储。</p>
<p>对于 &#39;cookie&#39;，我们还需要注意安全性。</p>
<p>|   属性    |                             作用                             |
| :-------: | :----------------------------------------------------------: |
|   value   | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 |
| http-only |            不能通过 JS 访问 Cookie，减少 XSS 攻击            |
|  secure   |               只能在协议为 HTTPS 的请求中携带                |
| same-site |    规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击     |

```
## 14.0 Service Worker
```
`
```
## 15.0 渲染机制
```

浏览器的渲染机制一般分为以下几个步骤</p>
<ol>
<li>处理 HTML 并构建 DOM 树。</li>
<li>处理 CSS 构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，计算每个节点的位置。</li>
<li>调用 GPU 绘制，合成图层，显示在屏幕上。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/11/162b2ab2ec70ac5b?w=900&amp;h=352&amp;f=png&amp;s=49983" alt=""></p>
<p>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 
树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越
是具体的 CSS 选择器，执行速度越慢。</p>
<p>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重
新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文
件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也
可以认为这种情况下，CSS 也会暂停构建 DOM。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/8/1647838a3b408372?w=1676&amp;h=688&amp;f=png&amp;s=154480" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/8/16478388e773b16a?w=1504&amp;h=760&amp;f=png&amp;s=123231" alt="">

```
## 16.0 Load 和 DOMContentLoaded 区别
```

Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。</p>
<p>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待
 CSS，JS，图片加载。

```
## 17.0 图层
```

一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。
<strong>不同的图层渲染互不影响</strong>，所以对于某些频繁需要渲染的建议单独生成一个新
图层，提高性能。但也不能生成过多的图层，会引起反作用。</p>
<p>通过以下几个常用属性可以生成新图层</p>
<p>  3D 变换：&#39;translate3d&#39;、&#39;translateZ&#39;
  &#39;will-change&#39;
  &#39;video&#39;、&#39;iframe&#39; 标签
  通过动画实现的 &#39;opacity&#39; 动画转换
  &#39;position: fixed&#39;

```
## 18.0 重绘（Repaint）和回流（Reflow）
```

重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。</p>
<p>  重绘是当节点需要更改外观而不会影响布局的，比如改变 &#39;color&#39; 就叫称
  为重绘
  回流是布局或者几何属性需要改变就称为回流。</p>
<p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，
改变深层次的节点很可能导致父节点的一系列回流。</p>
<p>所以以下几个动作可能会导致性能问题：</p>
<p>  改变 window 大小
  改变字体
  添加或删除样式
  文字改变
  定位或者浮动
  盒模型</p>
<p>很多人不知道的是，重绘和回流其实和 Event loop 有关。</p>
<ol>
<li>当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更
新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。</li>
<li>然后判断是否有 &#39;resize&#39; 或者 &#39;scroll&#39; ，有的话会去触发事件，所以
&#39;resize&#39; 和 &#39;scroll&#39; 事件也是至少 16ms 才会触发一次，并且自带节流
功能。</li>
<li>判断是否触发了 media query</li>
<li>更新动画并且发送事件</li>
<li>判断是否有全屏操作事件</li>
<li>执行 &#39;requestAnimationFrame&#39; 回调</li>
<li>执行 &#39;IntersectionObserver&#39; 回调，该方法用于判断元素是否可见，可
以用于懒加载上，但是兼容性不好</li>
<li>更新界面</li>
<li><p>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 
&#39;requestIdleCallback&#39; 回调。</p>
<p>以上内容来自于 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model">HTML 文档</a>

```
## 19.0 减少重绘和回流
```

使用 &#39;translate&#39; 替代 &#39;top&#39;</p>
<p>html
<div class="test"></div>
<style>
 .test {</p>
 position: absolute;
 top: 10px;
 width: 100px;
 height: 100px;
 background: red;
<p> }
</style></p>
<script>
 setTimeout(() => {
     // 引起回流
     document.querySelector('.test').style.top = '100px'
 }, 1000)
</script>

<p>使用 &#39;visibility&#39; 替换 &#39;display: none&#39; ，因为前者只会引起重绘，
后者会引发回流（改变了布局）</p>
<p>把 DOM 离线后修改，比如：先把 DOM 给 &#39;display:none&#39; (有一次 
Reflow)，然后你修改100次，然后再把它显示出来</p>
<p>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量</p>
</li>
</ol>
<p>js
  for(let i = 0; i &lt; 1000; i++) {
      // 获取 offsetTop 会导致回流，因为需要去获取正确的值
      console.log(document.querySelector(&#39;.test&#39;).style.offsetTop)
  }</p>
<p>  不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新
  布局</p>
<p>  动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 
  &#39;requestAnimationFrame&#39;</p>
<p>  CSS 选择符从右往左匹配查找，避免 DOM 深度过深</p>
<p>  将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如
  对于 &#39;video&#39; 标签，浏览器会自动将该节点变为图层。</p>
<p>  <img src="https://user-gold-cdn.xitu.io/2018/3/29/1626fb6f33a6f9d7?w=1588&amp;h=768&amp;f=png&amp;s=263260" alt="">

```
## 20.9 御修了ありがとうございました。
* certificatePath: https://firebasestorage.googleapis.com/v0/b/wohapp-3a179.appspot.com/o/knowledgecontents%2FiHmcxnnRDWPOJAE38On1nCdq0ir2%2F-LdLtaiBADqiIat-6k_dx20?alt=media&token=70c2e29c-49c1-45dd-a341-4cc012ca23a9
